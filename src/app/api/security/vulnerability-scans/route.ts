import { NextRequest, NextResponse } from 'next/server';
import { validateSession } from '@/lib/auth';
import { 
  startVulnerabilityScan, 
  getUserVulnerabilityScans,
  getVulnerabilityStats 
} from '@/lib/vulnerability-scanner';

export const runtime = 'nodejs';

// GET /api/security/vulnerability-scans - Get user's vulnerability scans
export async function GET(request: NextRequest) {
  try {
    const token = request.cookies.get('auth-token')?.value;
    
    if (!token) {
      return NextResponse.json({
        success: false,
        error: 'Authentication required',
      }, { status: 401 });
    }

    const authResult = await validateSession(token);
    if (!authResult.valid || !authResult.user) {
      return NextResponse.json({
        success: false,
        error: 'Invalid session',
      }, { status: 401 });
    }

    const url = new URL(request.url);
    const type = url.searchParams.get('type');

    if (type === 'stats' && authResult.user.is_admin) {
      const timeframe = url.searchParams.get('timeframe') as '24h' | '7d' | '30d' || '7d';
      const stats = await getVulnerabilityStats(timeframe);
      
      return NextResponse.json({
        success: true,
        stats,
        timeframe
      });
    } else {
      const limit = parseInt(url.searchParams.get('limit') || '20');
      const scans = await getUserVulnerabilityScans(authResult.user.id, limit);
      
      return NextResponse.json({
        success: true,
        scans
      });
    }

  } catch (error) {
    console.error('Error in vulnerability scans API:', error);
    return NextResponse.json({
      success: false,
      error: 'Internal server error',
    }, { status: 500 });
  }
}

// POST /api/security/vulnerability-scans - Start a new vulnerability scan
export async function POST(request: NextRequest) {
  try {
    const token = request.cookies.get('auth-token')?.value;
    
    if (!token) {
      return NextResponse.json({
        success: false,
        error: 'Authentication required',
      }, { status: 401 });
    }

    const authResult = await validateSession(token);
    if (!authResult.valid || !authResult.user) {
      return NextResponse.json({
        success: false,
        error: 'Invalid session',
      }, { status: 401 });
    }

    const body = await request.json();
    
    // Validate required fields
    const requiredFields = ['scan_type', 'target_url', 'target_description'];
    for (const field of requiredFields) {
      if (!body[field]) {
        return NextResponse.json({
          success: false,
          error: `Missing required field: ${field}`,
        }, { status: 400 });
      }
    }

    // Validate scan type
    const validScanTypes = ['web_app', 'network', 'dependency', 'code'];
    if (!validScanTypes.includes(body.scan_type)) {
      return NextResponse.json({
        success: false,
        error: 'Invalid scan type',
      }, { status: 400 });
    }

    // Basic URL validation for web_app scans
    if (body.scan_type === 'web_app') {
      try {
        new URL(body.target_url);
      } catch {
        return NextResponse.json({
          success: false,
          error: 'Invalid target URL',
        }, { status: 400 });
      }

      // Security check: prevent scanning of internal/private networks
      const url = new URL(body.target_url);
      const hostname = url.hostname;
      
      // Block localhost, private IPs, etc.
      if (hostname === 'localhost' || 
          hostname === '127.0.0.1' ||
          hostname.startsWith('192.168.') ||
          hostname.startsWith('10.') ||
          hostname.startsWith('172.')) {
        return NextResponse.json({
          success: false,
          error: 'Scanning of internal/private networks is not allowed',
        }, { status: 400 });
      }
    }

    const sourceIp = request.headers.get('x-forwarded-for') || 
                    request.headers.get('x-real-ip') || 
                    'unknown';

    const result = await startVulnerabilityScan(
      body.scan_type,
      body.target_url,
      body.target_description,
      body.scan_config || {},
      authResult.user.id,
      sourceIp
    );

    if (!result.success) {
      return NextResponse.json({
        success: false,
        error: result.error,
      }, { status: 400 });
    }

    return NextResponse.json({
      success: true,
      scan_id: result.scan_id,
      message: 'Vulnerability scan started successfully'
    });

  } catch (error) {
    console.error('Error starting vulnerability scan:', error);
    return NextResponse.json({
      success: false,
      error: 'Internal server error',
    }, { status: 500 });
  }
}
