import { supabaseAdmin } from './supabase';
import { VulnerabilityScan } from '@/types/database';
import { logSecurityEvent } from './security-audit';

/**
 * Vulnerability assessment and scanning system
 * For educational and authorized penetration testing purposes
 */

interface VulnerabilityFinding {
  id: string;
  title: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  cvss_score?: number;
  description: string;
  location?: string;
  evidence?: string;
  remediation?: string;
  references?: string[];
}

/**
 * Start a vulnerability scan
 */
export async function startVulnerabilityScan(
  scanType: 'web_app' | 'network' | 'dependency' | 'code',
  targetUrl: string,
  targetDescription: string,
  scanConfig: Record<string, any>,
  startedBy: string,
  sourceIp?: string
): Promise<{ success: boolean; scan_id?: string; error?: string }> {
  try {
    // Create scan record
    const { data: scan, error } = await supabaseAdmin
      .from('vulnerability_scans')
      .insert({
        scan_type: scanType,
        target_url: targetUrl,
        target_description: targetDescription,
        scan_status: 'pending',
        started_by: startedBy,
        scan_config: scanConfig,
        vulnerabilities_found: [],
        raw_results: {},
        risk_summary: {
          critical: 0,
          high: 0,
          medium: 0,
          low: 0,
          info: 0
        },
        recommendations: []
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating vulnerability scan:', error);
      return { success: false, error: 'Failed to create scan' };
    }

    // Log scan initiation
    await logSecurityEvent({
      user_id: startedBy,
      event_type: 'vulnerability_scan_started',
      event_category: 'security',
      severity: 'info',
      source_ip: sourceIp,
      resource_accessed: `/scans/${scan.id}`,
      action_details: {
        scan_id: scan.id,
        scan_type: scanType,
        target_url: targetUrl,
        scan_config: scanConfig
      },
      success: true
    });

    // Start the actual scan (in background)
    performVulnerabilityScan(scan.id, scanType, targetUrl, scanConfig);

    return { success: true, scan_id: scan.id };

  } catch (error) {
    console.error('Error in startVulnerabilityScan:', error);
    return { success: false, error: 'Internal server error' };
  }
}

/**
 * Perform the actual vulnerability scan (simulated for demo)
 */
async function performVulnerabilityScan(
  scanId: string,
  scanType: string,
  targetUrl: string,
  scanConfig: Record<string, any>
): Promise<void> {
  try {
    // Update scan status to running
    await supabaseAdmin
      .from('vulnerability_scans')
      .update({ scan_status: 'running' })
      .eq('id', scanId);

    // Simulate scan execution time
    await new Promise(resolve => setTimeout(resolve, 5000));

    // Generate simulated vulnerabilities based on scan type
    const vulnerabilities = generateSimulatedVulnerabilities(scanType, targetUrl);
    
    // Calculate risk summary
    const riskSummary = {
      critical: vulnerabilities.filter(v => v.severity === 'critical').length,
      high: vulnerabilities.filter(v => v.severity === 'high').length,
      medium: vulnerabilities.filter(v => v.severity === 'medium').length,
      low: vulnerabilities.filter(v => v.severity === 'low').length,
      info: vulnerabilities.filter(v => v.severity === 'info').length
    };

    // Generate recommendations
    const recommendations = generateRecommendations(vulnerabilities);

    // Update scan with results
    const { error } = await supabaseAdmin
      .from('vulnerability_scans')
      .update({
        scan_status: 'completed',
        vulnerabilities_found: vulnerabilities,
        risk_summary: riskSummary,
        recommendations: recommendations,
        completed_at: new Date().toISOString(),
        duration: 5 // Simulated 5 seconds
      })
      .eq('id', scanId);

    if (error) {
      console.error('Error updating scan results:', error);
    }

  } catch (error) {
    console.error('Error in performVulnerabilityScan:', error);
    
    // Mark scan as failed
    await supabaseAdmin
      .from('vulnerability_scans')
      .update({
        scan_status: 'failed',
        completed_at: new Date().toISOString()
      })
      .eq('id', scanId);
  }
}

/**
 * Generate simulated vulnerabilities for educational purposes
 */
function generateSimulatedVulnerabilities(
  scanType: string,
  targetUrl: string
): VulnerabilityFinding[] {
  const vulnerabilities: VulnerabilityFinding[] = [];

  if (scanType === 'web_app') {
    vulnerabilities.push(
      {
        id: 'xss-001',
        title: 'Cross-Site Scripting (XSS) - Reflected',
        severity: 'high',
        cvss_score: 7.5,
        description: 'The application reflects user input without proper sanitization, allowing for script injection.',
        location: `${targetUrl}/search?q=<script>alert(1)</script>`,
        evidence: 'User input is directly reflected in the response without encoding',
        remediation: 'Implement proper input validation and output encoding',
        references: ['https://owasp.org/www-community/attacks/xss/']
      },
      {
        id: 'sql-001',
        title: 'SQL Injection',
        severity: 'critical',
        cvss_score: 9.8,
        description: 'The application is vulnerable to SQL injection attacks through user input parameters.',
        location: `${targetUrl}/login`,
        evidence: 'Error-based SQL injection detected in username parameter',
        remediation: 'Use parameterized queries and input validation',
        references: ['https://owasp.org/www-community/attacks/SQL_Injection']
      },
      {
        id: 'csrf-001',
        title: 'Cross-Site Request Forgery (CSRF)',
        severity: 'medium',
        cvss_score: 6.1,
        description: 'The application lacks CSRF protection on state-changing operations.',
        location: `${targetUrl}/admin/delete-user`,
        evidence: 'No CSRF tokens found in forms',
        remediation: 'Implement CSRF tokens for all state-changing operations',
        references: ['https://owasp.org/www-community/attacks/csrf']
      }
    );
  } else if (scanType === 'network') {
    vulnerabilities.push(
      {
        id: 'port-001',
        title: 'Unnecessary Open Ports',
        severity: 'medium',
        cvss_score: 5.3,
        description: 'Several unnecessary ports are open and accessible from the internet.',
        location: 'Ports 21, 23, 135, 445',
        evidence: 'FTP, Telnet, and SMB services exposed',
        remediation: 'Close unnecessary ports and implement firewall rules',
        references: ['https://www.nist.gov/cybersecurity']
      },
      {
        id: 'ssl-001',
        title: 'Weak SSL/TLS Configuration',
        severity: 'high',
        cvss_score: 7.4,
        description: 'The server supports weak SSL/TLS protocols and cipher suites.',
        location: 'HTTPS service on port 443',
        evidence: 'TLS 1.0 and weak ciphers detected',
        remediation: 'Disable weak protocols and enable only strong cipher suites',
        references: ['https://ssl-config.mozilla.org/']
      }
    );
  } else if (scanType === 'dependency') {
    vulnerabilities.push(
      {
        id: 'dep-001',
        title: 'Outdated Dependencies with Known Vulnerabilities',
        severity: 'high',
        cvss_score: 8.1,
        description: 'Several dependencies have known security vulnerabilities.',
        location: 'package.json / requirements.txt',
        evidence: 'lodash@4.17.15 (CVE-2020-8203), express@4.16.0 (CVE-2022-24999)',
        remediation: 'Update all dependencies to their latest secure versions',
        references: ['https://nvd.nist.gov/', 'https://snyk.io/vuln/']
      }
    );
  }

  return vulnerabilities;
}

/**
 * Generate security recommendations based on findings
 */
function generateRecommendations(vulnerabilities: VulnerabilityFinding[]): string[] {
  const recommendations: string[] = [];

  const hasCritical = vulnerabilities.some(v => v.severity === 'critical');
  const hasHigh = vulnerabilities.some(v => v.severity === 'high');
  const hasXSS = vulnerabilities.some(v => v.title.toLowerCase().includes('xss'));
  const hasSQL = vulnerabilities.some(v => v.title.toLowerCase().includes('sql'));

  if (hasCritical) {
    recommendations.push('Immediately address all critical vulnerabilities as they pose severe security risks');
  }

  if (hasHigh) {
    recommendations.push('Prioritize fixing high-severity vulnerabilities within the next sprint');
  }

  if (hasXSS) {
    recommendations.push('Implement a Content Security Policy (CSP) to mitigate XSS attacks');
    recommendations.push('Use a web application firewall (WAF) for additional protection');
  }

  if (hasSQL) {
    recommendations.push('Conduct a comprehensive code review focusing on database interactions');
    recommendations.push('Implement database activity monitoring');
  }

  recommendations.push('Establish a regular vulnerability scanning schedule');
  recommendations.push('Provide security training for the development team');
  recommendations.push('Implement a bug bounty program for continuous security testing');

  return recommendations;
}

/**
 * Get vulnerability scan results
 */
export async function getVulnerabilityScan(
  scanId: string,
  userId: string
): Promise<{ success: boolean; scan?: VulnerabilityScan; error?: string }> {
  try {
    const { data: scan, error } = await supabaseAdmin
      .from('vulnerability_scans')
      .select('*')
      .eq('id', scanId)
      .single();

    if (error) {
      console.error('Error fetching vulnerability scan:', error);
      return { success: false, error: 'Scan not found' };
    }

    // Check if user has permission to view this scan
    if (scan.started_by !== userId) {
      // Check if user is admin
      const { data: user } = await supabaseAdmin
        .from('users')
        .select('is_admin')
        .eq('id', userId)
        .single();

      if (!user?.is_admin) {
        return { success: false, error: 'Access denied' };
      }
    }

    return { success: true, scan };

  } catch (error) {
    console.error('Error in getVulnerabilityScan:', error);
    return { success: false, error: 'Internal server error' };
  }
}

/**
 * Get user's vulnerability scans
 */
export async function getUserVulnerabilityScans(
  userId: string,
  limit: number = 20
): Promise<VulnerabilityScan[]> {
  try {
    const { data: scans, error } = await supabaseAdmin
      .from('vulnerability_scans')
      .select('*')
      .eq('started_by', userId)
      .order('started_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error fetching user vulnerability scans:', error);
      return [];
    }

    return scans || [];

  } catch (error) {
    console.error('Error in getUserVulnerabilityScans:', error);
    return [];
  }
}

/**
 * Get vulnerability statistics
 */
export async function getVulnerabilityStats(timeframe: '24h' | '7d' | '30d' = '7d'): Promise<{
  total_scans: number;
  completed_scans: number;
  total_vulnerabilities: number;
  severity_breakdown: Record<string, number>;
  scan_types: Record<string, number>;
  top_vulnerabilities: Array<{ title: string; count: number }>;
}> {
  try {
    const hours = timeframe === '24h' ? 24 : timeframe === '7d' ? 168 : 720;
    const startTime = new Date();
    startTime.setHours(startTime.getHours() - hours);

    const { data: scans, error } = await supabaseAdmin
      .from('vulnerability_scans')
      .select('*')
      .gte('started_at', startTime.toISOString());

    if (error || !scans) {
      return {
        total_scans: 0,
        completed_scans: 0,
        total_vulnerabilities: 0,
        severity_breakdown: {},
        scan_types: {},
        top_vulnerabilities: []
      };
    }

    const totalScans = scans.length;
    const completedScans = scans.filter(s => s.scan_status === 'completed').length;

    // Aggregate vulnerabilities
    const allVulnerabilities: VulnerabilityFinding[] = [];
    scans.forEach(scan => {
      if (scan.vulnerabilities_found) {
        allVulnerabilities.push(...(scan.vulnerabilities_found as VulnerabilityFinding[]));
      }
    });

    const severityBreakdown: Record<string, number> = {};
    const vulnerabilityTitles: Record<string, number> = {};
    const scanTypes: Record<string, number> = {};

    allVulnerabilities.forEach(vuln => {
      severityBreakdown[vuln.severity] = (severityBreakdown[vuln.severity] || 0) + 1;
      vulnerabilityTitles[vuln.title] = (vulnerabilityTitles[vuln.title] || 0) + 1;
    });

    scans.forEach(scan => {
      scanTypes[scan.scan_type] = (scanTypes[scan.scan_type] || 0) + 1;
    });

    const topVulnerabilities = Object.entries(vulnerabilityTitles)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .map(([title, count]) => ({ title, count }));

    return {
      total_scans: totalScans,
      completed_scans: completedScans,
      total_vulnerabilities: allVulnerabilities.length,
      severity_breakdown: severityBreakdown,
      scan_types: scanTypes,
      top_vulnerabilities: topVulnerabilities
    };

  } catch (error) {
    console.error('Error in getVulnerabilityStats:', error);
    return {
      total_scans: 0,
      completed_scans: 0,
      total_vulnerabilities: 0,
      severity_breakdown: {},
      scan_types: {},
      top_vulnerabilities: []
    };
  }
}
